# .zshrc.env
# Áí∞Â¢É„Åî„Å®„ÅÆË®≠ÂÆö„ÇíÊõ∏„ÅÑ„Åü„Çä„Åô„Çã„Éï„Ç°„Ç§„É´

# Ë£úÂÆåÈñ¢Êï∞„ÅÆ„É≠„Éº„Éâ
fpath=($HOME/.zsh_fun $fpath)

# „Éë„Çπ„ÅÆË®≠ÂÆö
export PATH=$HOME/local/bin:/usr/local/bin:/usr/local/sbin:$PATH

# perlbrew
[ -f ~/perl5/perlbrew/etc/bashrc ] && source ~/perl5/perlbrew/etc/bashrc

# virtualenv
export WORKON_HOME=$HOME/.virtualenvs
[ -f /usr/local/bin/virtualenvwrapper.sh ] && source /usr/local/bin/virtualenvwrapper.sh

# nodebrew
export PATH=$HOME/.nodebrew/current/bin:$PATH

# rbenv
eval "$(rbenv init -)"

# z
source `brew --prefix`/etc/profile.d/z.sh

# screen auto startup
if [ $TERM != "screen" -a "`screen -ls | grep Attache`" = "" ]; then
    screen -US hokamura -xRR
fi

# screen„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„É©„Ç§„É≥„Å´ÊúÄÂæå„Å´ÂÆüË°å„Åó„Åü„Ç≥„Éû„É≥„Éâ„ÇíË°®Á§∫
if [ "$TERM" = "screen" ]; then
    #chpwd () { echo -n "_`dirs`\\" }
    preexec() {
        # see [zsh-workers:13180]
        # http://www.zsh.org/mla/workers/2000/msg03993.html
        emulate -L zsh
        local -a cmd; cmd=(${(z)2})
        case $cmd[1] in
            fg)
                if (( $#cmd == 1 )); then
                    cmd=(builtin jobs -l %+)
                else
                    cmd=(builtin jobs -l $cmd[2])
                fi
                ;;
            %*) 
                cmd=(builtin jobs -l $cmd[1])
                ;;
            cd)
                if (( $#cmd == 2)); then
                    cmd[1]=$cmd[2]
                fi
                ;&
            *)
                echo -n "k$cmd[1]:t\\"
                return
                ;;
        esac

        local -A jt; jt=(${(kv)jobtexts})

        $cmd >>(read num rest
            cmd=(${(z)${(e):-\$jt$num}})
            echo -n "k$cmd[1]:t\\") 2>/dev/null
    }
    chpwd () {}
fi

# Èñ¢Êï∞„ÇÑalias„Å™„Å©
alias -g G="| grep"
alias -g L="| less"
alias -g V="| vi -"

function alc() {
  if [ $# != 0 ]; then
    w3m "http://eow.alc.co.jp/$*/UTF-8/?ref=sa" | less +37
    #w3m "http://eow.alc.co.jp/$*/UTF-8/?ref=sa"
  else
    echo 'usage: alc word'
  fi
}

function pminfo() {
  if [ $# != 0 ]; then
    perl -le 'eval "require $ARGV[0]";print ${"${ARGV[0]}::VERSION"};print qx/perldoc -ml $ARGV[0]/' $*
  else
    echo 'usage: pminfo perlmodule'
  fi
}

function url_decode() {
  if [ $# != 0 ]; then
    perl -MURI::Escape -wle 'print uri_unescape $ARGV[0]' $*
  else
    echo 'usage: url_decode url'
  fi
}

function imageinfo() {
  if [ $# != 0 ]; then
    perl -MImage::Info -MYAML -le 'print $_, "\n", Dump Image::Info::image_info($_) for @ARGV'
  else
    echo 'usage: imageinfo file [file..]'
  fi
}

function base64() {
  if [ $# != 0 ]; then
    perl -MMIME::Base64 -0777 -wne 'print encode_base64($_,"")' < $*
  else
    echo 'usage: base64 file'
  fi
}

# Ë£úÂÆåÈñ¢Êï∞„É™„Çª„ÉÉ„Éà
function r() {
  local f
  f=(~/.zsh_fun/*(.))
  unfunction $f:t 2> /dev/null
  autoload -U $f:t
}

# macvim
if [ -f /Applications/MacVim.app/Contents/MacOS/Vim ]; then
  alias vim="/Applications/MacVim.app/Contents/MacOS/Vim -g --remote-tab-silent"
fi

# jsonview
alias jsonview="perl -MJSON::XS -e 'print JSON::XS->new->utf8->pretty->encode(decode_json <STDIN>)'"

# svn
alias svnadd="svn st | grep '^?' | awk '{ print \$2 }' | xargs svn add"
alias svndel="svn st | grep '^!' | awk '{ print \$2 }' | xargs svn delete"
alias svnrm='find . -name ".svn" -type d | xargs rm -rf'

# pydoc
alias pydoc="python `which pydoc`"

# bundle 
alias be="bundle exec"
alias bi="bundle install --without=production --path vendor/bundle"
